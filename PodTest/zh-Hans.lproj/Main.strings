
/* Class = "UITextView"; text = "/*:\n # Data types conversinn\n */\nlet data = Data(bytes: [0x01, 0x02, 0x03])\nlet bytes = data.bytes\nlet bytesHex = Array<UInt8>(hex: \"0x010203\")\nlet hexString = bytesHex.toHexString()\n\n/*:\n # Digest\n */\ndata.md5()\ndata.sha1()\ndata.sha224()\ndata.sha256()\ndata.sha384()\ndata.sha512()\n\nbytes.sha1()\n\"123\".sha1()\nDigest.sha1(bytes)\n\n//: Digest calculated incrementally\ndo {\n    var digest = MD5()\n    _ = try digest.update(withBytes: [0x31, 0x32])\n    _ = try digest.update(withBytes: [0x33])\n    let result = try digest.finish()\n    print(result)\n} catch {}\n\n/*:\n # CRC\n */\nbytes.crc16()\nbytes.crc32()\n\n/*:\n # HMAC\n */\n\ndo {\n    let key: Array<UInt8> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 23, 25, 26, 27, 28, 29, 30, 31, 32]\n    try Poly1305(key: key).authenticate(bytes)\n    try HMAC(key: key, variant: .sha256).authenticate(bytes)\n} catch {}\n\n/*:\n # PBKDF1, PBKDF2\n */\n\ndo {\n    let password: Array<UInt8> = Array(\"s33krit\".utf8)\n    let salt: Array<UInt8> = Array(\"nacllcan\".utf8)\n\n    try PKCS5.PBKDF1(password: password, salt: salt, variant: .sha1, iterations: 4096).calculate()\n\n    let value = try PKCS5.PBKDF2(password: password, salt: salt, iterations: 4096, variant: .sha256).calculate()\n    print(value)\n} catch {}\n\n/*:\n # Padding\n */\nPadding.pkcs7.add(to: bytes, blockSize: AES.blockSize)\n\n/*:\n # ChaCha20\n */\n\ndo {\n    let key: Array<UInt8> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]\n    let iv: Array<UInt8> = [1, 2, 3, 4, 5, 6, 7, 8]\n    let message = Array<UInt8>(repeating: 7, count: 10)\n\n    let encrypted = try ChaCha20(key: key, iv: iv).encrypt(message)\n    let decrypted = try ChaCha20(key: key, iv: iv).decrypt(encrypted)\n    print(decrypted)\n} catch {\n    print(error)\n}\n\n/*:\n # AES\n ### One-time shot.\n Encrypt all data at once.\n */\ndo {\n    let aes = try AES(key: \"passwordpassword\", iv: \"drowssapdrowssap\") // aes128\n    let ciphertext = try aes.encrypt(Array(\"Nullam quis risus eget urna mollis ornare vel eu leo.\".utf8))\n    print(ciphertext.toHexString())\n} catch {\n    print(error)\n}\n\n/*:\n ### Incremental encryption\n Instantiate Encryptor for AES encryption (or decryptor for decryption) and process input data partially.\n */\ndo {\n    var encryptor = try AES(key: \"passwordpassword\", iv: \"drowssapdrowssap\").makeEncryptor()\n\n    var ciphertext = Array<UInt8>()\n    // aggregate partial results\n    ciphertext += try encryptor.update(withBytes: Array(\"Nullam quis risus \".utf8))\n    ciphertext += try encryptor.update(withBytes: Array(\"eget urna mollis \".utf8))\n    ciphertext += try encryptor.update(withBytes: Array(\"ornare vel eu leo.\".utf8))\n    // finish at the end\n    ciphertext += try encryptor.finish()\n\n    print(ciphertext.toHexString())\n} catch {\n    print(error)\n}\n\n/*:\n ### Encrypt stream\n */\ndo {\n    // write until all is written\n    func writeTo(stream: OutputStream, bytes: Array<UInt8>) {\n        var writtenCount = 0\n        while stream.hasSpaceAvailable && writtenCount < bytes.count {\n            writtenCount += stream.write(bytes, maxLength: bytes.count)\n        }\n    }\n\n    let aes = try AES(key: \"passwordpassword\", iv: \"drowssapdrowssap\")\n    var encryptor = try! aes.makeEncryptor()\n\n    // prepare streams\n    let data = Data(bytes: (0..<100).map { $0 })\n    let inputStream = InputStream(data: data)\n    let outputStream = OutputStream(toMemory: ())\n    inputStream.open()\n    outputStream.open()\n\n    var buffer = Array<UInt8>(repeating: 0, count: 2)\n\n    // encrypt input stream data and write encrypted result to output stream\n    while inputStream.hasBytesAvailable {\n        let readCount = inputStream.read(&buffer, maxLength: buffer.count)\n        if readCount > 0 {\n            try encryptor.update(withBytes: buffer[0..<readCount]) { bytes in\n                writeTo(stream: outputStream, bytes: bytes)\n            }\n        }\n    }\n\n    // finalize encryption\n    try encryptor.finish { bytes in\n        writeTo(stream: outputStream, bytes: bytes)\n    }\n\n    // print result\n    if let ciphertext = outputStream.property(forKey: Stream.PropertyKey(rawValue: Stream.PropertyKey.dataWrittenToMemoryStreamKey.rawValue)) as? Data {\n        print(\"Encrypted stream data: \\(ciphertext.toHexString())\")\n    }\n\n} catch {\n    print(error)\n}"; ObjectID = "EBr-8F-Zxs"; */
"EBr-8F-Zxs.text" = "/*:\n # Data types conversinn\n */\nlet data = Data(bytes: [0x01, 0x02, 0x03])\nlet bytes = data.bytes\nlet bytesHex = Array<UInt8>(hex: \"0x010203\")\nlet hexString = bytesHex.toHexString()\n\n/*:\n # Digest\n */\ndata.md5()\ndata.sha1()\ndata.sha224()\ndata.sha256()\ndata.sha384()\ndata.sha512()\n\nbytes.sha1()\n\"123\".sha1()\nDigest.sha1(bytes)\n\n//: Digest calculated incrementally\ndo {\n    var digest = MD5()\n    _ = try digest.update(withBytes: [0x31, 0x32])\n    _ = try digest.update(withBytes: [0x33])\n    let result = try digest.finish()\n    print(result)\n} catch {}\n\n/*:\n # CRC\n */\nbytes.crc16()\nbytes.crc32()\n\n/*:\n # HMAC\n */\n\ndo {\n    let key: Array<UInt8> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 23, 25, 26, 27, 28, 29, 30, 31, 32]\n    try Poly1305(key: key).authenticate(bytes)\n    try HMAC(key: key, variant: .sha256).authenticate(bytes)\n} catch {}\n\n/*:\n # PBKDF1, PBKDF2\n */\n\ndo {\n    let password: Array<UInt8> = Array(\"s33krit\".utf8)\n    let salt: Array<UInt8> = Array(\"nacllcan\".utf8)\n\n    try PKCS5.PBKDF1(password: password, salt: salt, variant: .sha1, iterations: 4096).calculate()\n\n    let value = try PKCS5.PBKDF2(password: password, salt: salt, iterations: 4096, variant: .sha256).calculate()\n    print(value)\n} catch {}\n\n/*:\n # Padding\n */\nPadding.pkcs7.add(to: bytes, blockSize: AES.blockSize)\n\n/*:\n # ChaCha20\n */\n\ndo {\n    let key: Array<UInt8> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]\n    let iv: Array<UInt8> = [1, 2, 3, 4, 5, 6, 7, 8]\n    let message = Array<UInt8>(repeating: 7, count: 10)\n\n    let encrypted = try ChaCha20(key: key, iv: iv).encrypt(message)\n    let decrypted = try ChaCha20(key: key, iv: iv).decrypt(encrypted)\n    print(decrypted)\n} catch {\n    print(error)\n}\n\n/*:\n # AES\n ### One-time shot.\n Encrypt all data at once.\n */\ndo {\n    let aes = try AES(key: \"passwordpassword\", iv: \"drowssapdrowssap\") // aes128\n    let ciphertext = try aes.encrypt(Array(\"Nullam quis risus eget urna mollis ornare vel eu leo.\".utf8))\n    print(ciphertext.toHexString())\n} catch {\n    print(error)\n}\n\n/*:\n ### Incremental encryption\n Instantiate Encryptor for AES encryption (or decryptor for decryption) and process input data partially.\n */\ndo {\n    var encryptor = try AES(key: \"passwordpassword\", iv: \"drowssapdrowssap\").makeEncryptor()\n\n    var ciphertext = Array<UInt8>()\n    // aggregate partial results\n    ciphertext += try encryptor.update(withBytes: Array(\"Nullam quis risus \".utf8))\n    ciphertext += try encryptor.update(withBytes: Array(\"eget urna mollis \".utf8))\n    ciphertext += try encryptor.update(withBytes: Array(\"ornare vel eu leo.\".utf8))\n    // finish at the end\n    ciphertext += try encryptor.finish()\n\n    print(ciphertext.toHexString())\n} catch {\n    print(error)\n}\n\n/*:\n ### Encrypt stream\n */\ndo {\n    // write until all is written\n    func writeTo(stream: OutputStream, bytes: Array<UInt8>) {\n        var writtenCount = 0\n        while stream.hasSpaceAvailable && writtenCount < bytes.count {\n            writtenCount += stream.write(bytes, maxLength: bytes.count)\n        }\n    }\n\n    let aes = try AES(key: \"passwordpassword\", iv: \"drowssapdrowssap\")\n    var encryptor = try! aes.makeEncryptor()\n\n    // prepare streams\n    let data = Data(bytes: (0..<100).map { $0 })\n    let inputStream = InputStream(data: data)\n    let outputStream = OutputStream(toMemory: ())\n    inputStream.open()\n    outputStream.open()\n\n    var buffer = Array<UInt8>(repeating: 0, count: 2)\n\n    // encrypt input stream data and write encrypted result to output stream\n    while inputStream.hasBytesAvailable {\n        let readCount = inputStream.read(&buffer, maxLength: buffer.count)\n        if readCount > 0 {\n            try encryptor.update(withBytes: buffer[0..<readCount]) { bytes in\n                writeTo(stream: outputStream, bytes: bytes)\n            }\n        }\n    }\n\n    // finalize encryption\n    try encryptor.finish { bytes in\n        writeTo(stream: outputStream, bytes: bytes)\n    }\n\n    // print result\n    if let ciphertext = outputStream.property(forKey: Stream.PropertyKey(rawValue: Stream.PropertyKey.dataWrittenToMemoryStreamKey.rawValue)) as? Data {\n        print(\"Encrypted stream data: \\(ciphertext.toHexString())\")\n    }\n\n} catch {\n    print(error)\n}";

/* Class = "UIButton"; normalTitle = "中文"; ObjectID = "FeA-3u-Ab5"; */
"FeA-3u-Ab5.normalTitle" = "中文";

/* Class = "UILabel"; text = "see more info in output"; ObjectID = "GNx-xr-sgA"; */
"GNx-xr-sgA.text" = "see more info in output";

/* Class = "UIButton"; normalTitle = "When"; ObjectID = "JTh-NE-HT8"; */
"JTh-NE-HT8.normalTitle" = "When";

/* Class = "UILabel"; text = "Label"; ObjectID = "TAa-NT-Zhj"; */
"TAa-NT-Zhj.text" = "Label";

/* Class = "UILabel"; text = "支持的版本(终端输入swift查看版本)"; ObjectID = "ZXS-jx-d6x"; */
"ZXS-jx-d6x.text" = "支持的版本(终端输入swift查看版本)";

/* Class = "UILabel"; text = "Label"; ObjectID = "bR4-ai-iIF"; */
"bR4-ai-iIF.text" = "Label";

/* Class = "UIButton"; normalTitle = "英文"; ObjectID = "baG-Ey-aFv"; */
"baG-Ey-aFv.normalTitle" = "英文";

/* Class = "UIButton"; normalTitle = "Button"; ObjectID = "f6I-hQ-yfb"; */
"f6I-hQ-yfb.normalTitle" = "Button";

/* Class = "UIButton"; normalTitle = "CheckVersion"; ObjectID = "gvq-DB-Val"; */
"gvq-DB-Val.normalTitle" = "CheckVersion";

/* Class = "UILabel"; text = "Label"; ObjectID = "jfu-Ua-0hu"; */
"jfu-Ua-0hu.text" = "Label";

/* Class = "UIButton"; normalTitle = "Then,链式"; ObjectID = "lLk-vm-MCv"; */
"lLk-vm-MCv.normalTitle" = "Then,链式";

/* Class = "UITextView"; text = "Swift 1.2: branch swift12 version <= 0.0.13\nSwift 2.1: branch swift21 version <= 0.2.3\nSwift 2.2, 2.3: branch swift2 version <= 0.5.2\nSwift 3.1, branch swift3 version <= 0.6.9\nSwift 3.2, branch swift32 version = 0.7.0\nSwift 4.0, branch master version >= 0.7.1"; ObjectID = "uCC-KS-Yfm"; */
"uCC-KS-Yfm.text" = "Swift 1.2: branch swift12 version <= 0.0.13\nSwift 2.1: branch swift21 version <= 0.2.3\nSwift 2.2, 2.3: branch swift2 version <= 0.5.2\nSwift 3.1, branch swift3 version <= 0.6.9\nSwift 3.2, branch swift32 version = 0.7.0\nSwift 4.0, branch master version >= 0.7.1";
